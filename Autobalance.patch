Index: src/server/game/Entities/Creature/Creature.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/server/game/Entities/Creature/Creature.cpp	(revision 01a1367cfab6a15db39407c3295370fcaa286899)
+++ src/server/game/Entities/Creature/Creature.cpp	(revision b38f07b8669910b247e3aea4d003b588ba644cb1)
@@ -838,6 +838,7 @@
         default:
             break;
     }
+    sScriptMgr->OnCreatureUpdate(this, diff);
 }
 
 void Creature::Regenerate(Powers power)
@@ -1450,6 +1451,8 @@
 
     float armor = (float)stats->GenerateArmor(cInfo); /// @todo Why is this treated as uint32 when it's a float?
     SetStatFlatModifier(UNIT_MOD_ARMOR, BASE_VALUE, armor);
+
+    sScriptMgr->Creature_SelectLevel(cInfo, this);
 }
 
 float Creature::_GetHealthMod(int32 Rank)
Index: src/server/game/Entities/Unit/Unit.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/server/game/Entities/Unit/Unit.cpp	(revision 01a1367cfab6a15db39407c3295370fcaa286899)
+++ src/server/game/Entities/Unit/Unit.cpp	(revision b38f07b8669910b247e3aea4d003b588ba644cb1)
@@ -6339,7 +6339,10 @@
 int32 Unit::HealBySpell(HealInfo& healInfo, bool critical /*= false*/)
 {
     // calculate heal absorb and reduce healing
+    Unit* victim = healInfo.GetTarget();
+    uint32 addhealth = healInfo.GetHeal();
     Unit::CalcHealAbsorb(healInfo);
+    sScriptMgr->ModifyHealRecieved(this, victim, addhealth);
     Unit::DealHeal(healInfo);
     SendHealSpellLog(healInfo, critical);
     return healInfo.GetEffectiveHeal();
Index: src/server/game/Scripting/ScriptMgr.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/server/game/Scripting/ScriptMgr.cpp	(revision 01a1367cfab6a15db39407c3295370fcaa286899)
+++ src/server/game/Scripting/ScriptMgr.cpp	(revision b38f07b8669910b247e3aea4d003b588ba644cb1)
@@ -1326,6 +1326,19 @@
     FOREACH_SCRIPT(WorldScript)->OnUpdate(diff);
 }
 
+void ScriptMgr::SetInitialWorldSettings()
+{
+    FOREACH_SCRIPT(WorldScript)->SetInitialWorldSettings();
+}
+
+float ScriptMgr::VAS_Script_Hooks() {
+    float VAS_Script_Hook_Version = 1.03f;
+    return VAS_Script_Hook_Version;
+}
+
 void ScriptMgr::OnHonorCalculation(float& honor, uint8 level, float multiplier)
 {
     FOREACH_SCRIPT(FormulaScript)->OnHonorCalculation(honor, level, multiplier);
@@ -1456,6 +1469,8 @@
     ASSERT(map);
     ASSERT(player);
 
+    FOREACH_SCRIPT(AllMapScript)->OnPlayerEnterAll(map, player);
+
     FOREACH_SCRIPT(PlayerScript)->OnMapChanged(player);
 
     SCR_MAP_BGN(WorldMapScript, map, itr, end, entry, IsWorldMap);
@@ -1476,6 +1491,8 @@
     ASSERT(map);
     ASSERT(player);
 
+    FOREACH_SCRIPT(AllMapScript)->OnPlayerLeaveAll(map, player);
+
     SCR_MAP_BGN(WorldMapScript, map, itr, end, entry, IsWorldMap);
         itr->second->OnPlayerLeave(map, player);
     SCR_MAP_END;
@@ -2121,6 +2138,34 @@
     FOREACH_SCRIPT(CreatureScript)->ModifyVehiclePassengerExitPos(passenger, vehicle, pos);
 }
 
+void ScriptMgr::ModifyHealRecieved(Unit *target, Unit *attacker, uint32 &damage) {
+    FOREACH_SCRIPT(UnitScript)->ModifyHealRecieved(target, attacker, damage);
+}
+
+//Called From Unit::DealDamage
+//uint32 ScriptMgr::DealDamage(Unit *AttackerUnit, Unit *pVictim, uint32 damage, DamageEffectType damagetype) {
+//    FOR_SCRIPTS_RET(UnitScript, itr, end, damage)damage = itr->second->DealDamage(AttackerUnit, pVictim, damage, damagetype);
+//    return damage;
+//}
+
+AllMapScript::AllMapScript(const char *name)
+        : ScriptObject(name) {
+    ScriptRegistry<AllMapScript>::Instance()->AddScript(this);
+}
+
+AllCreatureScript::AllCreatureScript(const char *name)
+        : ScriptObject(name) {
+    ScriptRegistry<AllCreatureScript>::Instance()->AddScript(this);
+}
+
+void ScriptMgr::OnCreatureUpdate(Creature *creature, uint32 diff) {
+    FOREACH_SCRIPT(AllCreatureScript)->OnAllCreatureUpdate(creature, diff);
+}
+
+void ScriptMgr::Creature_SelectLevel(const CreatureTemplate *cinfo, Creature *creature) {
+    FOREACH_SCRIPT(AllCreatureScript)->Creature_SelectLevel(cinfo, creature);
+}
+
 SpellScriptLoader::SpellScriptLoader(char const* name)
     : ScriptObject(name)
 {
@@ -2315,10 +2360,12 @@
 template class TC_GAME_API ScriptRegistry<ServerScript>;
 template class TC_GAME_API ScriptRegistry<WorldScript>;
 template class TC_GAME_API ScriptRegistry<FormulaScript>;
+template class TC_GAME_API ScriptRegistry<AllMapScript>;
 template class TC_GAME_API ScriptRegistry<WorldMapScript>;
 template class TC_GAME_API ScriptRegistry<InstanceMapScript>;
 template class TC_GAME_API ScriptRegistry<BattlegroundMapScript>;
 template class TC_GAME_API ScriptRegistry<ItemScript>;
+template class TC_GAME_API ScriptRegistry<AllCreatureScript>;
 template class TC_GAME_API ScriptRegistry<CreatureScript>;
 template class TC_GAME_API ScriptRegistry<GameObjectScript>;
 template class TC_GAME_API ScriptRegistry<AreaTriggerScript>;
Index: src/server/game/Scripting/ScriptMgr.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/server/game/Scripting/ScriptMgr.h	(revision 01a1367cfab6a15db39407c3295370fcaa286899)
+++ src/server/game/Scripting/ScriptMgr.h	(revision b38f07b8669910b247e3aea4d003b588ba644cb1)
@@ -20,6 +20,7 @@
 
 #include "Common.h"
 #include "ObjectGuid.h"
+#include "Unit.h"
 #include <vector>
 
 class AccountMgr;
@@ -271,6 +272,9 @@
 
         // Called when the world is actually shut down.
         virtual void OnShutdown() { }
+
+        // Called at End of SetInitialWorldSettings.
+        virtual void SetInitialWorldSettings() { }
 };
 
 class TC_GAME_API FormulaScript : public ScriptObject
@@ -303,6 +307,21 @@
         virtual void OnGroupRateCalculation(float& /*rate*/, uint32 /*count*/, bool /*isRaid*/) { }
 };
 
+class AllMapScript : public ScriptObject
+{
+    protected:
+
+        AllMapScript(const char* name);
+
+    public:
+
+        // Called when a player enters any Map
+        virtual void OnPlayerEnterAll(Map* /*map*/, Player* /*player*/) { }
+
+        // Called when a player leave any Map
+        virtual void OnPlayerLeaveAll(Map* /*map*/, Player* /*player*/) { }
+};
+
 template<class TMap> class MapScript : public UpdatableScript<TMap>
 {
     MapEntry const* _mapEntry;
@@ -410,6 +429,12 @@
 
         // Called when an unit exits a vehicle
         virtual void ModifyVehiclePassengerExitPos(Unit* /*passenger*/, Vehicle* /*vehicle*/, Position& /*pos*/) { }
+
+        // Called when Heal is Recieved
+        virtual void ModifyHealRecieved(Unit* /*target*/, Unit* /*attacker*/, uint32& /*damage*/) { }
+
+        //VAS AutoBalance
+        // virtual uint32 DealDamage(Unit* AttackerUnit, Unit *pVictim, uint32 damage, DamageEffectType damagetype) { return damage;}
 };
 
 class TC_GAME_API CreatureScript : public ScriptObject
@@ -426,6 +451,21 @@
         virtual CreatureAI* GetAI(Creature* /*creature*/) const = 0;
 };
 
+class TC_GAME_API AllCreatureScript : public ScriptObject
+{
+    protected:
+
+        AllCreatureScript(const char* name);
+
+    public:
+
+        // Called from End of Creature Update.
+        virtual void OnAllCreatureUpdate(Creature* /*creature*/, uint32 /*diff*/) { }
+
+        // Called from End of Creature SelectLevel.
+        virtual void Creature_SelectLevel(const CreatureTemplate* /*cinfo*/, Creature* /*creature*/) { }
+};
+
 class TC_GAME_API GameObjectScript : public ScriptObject
 {
     protected:
@@ -868,6 +908,10 @@
 
         void Unload();
 
+    public: /* {VAS} Script Hooks */
+
+        float VAS_Script_Hooks();
+
     public: /* SpellScriptLoader */
 
         void CreateSpellScripts(uint32 spellId, std::vector<SpellScript*>& scriptVector, Spell* invoker) const;
@@ -893,6 +937,7 @@
         void OnWorldUpdate(uint32 diff);
         void OnStartup();
         void OnShutdown();
+        void SetInitialWorldSettings();
 
     public: /* FormulaScript */
 
@@ -904,6 +949,11 @@
         void OnGainCalculation(uint32& gain, Player* player, Unit* unit);
         void OnGroupRateCalculation(float& rate, uint32 count, bool isRaid);
 
+    public: /* AllScript */
+
+        void OnPlayerEnterMapAll(Map* map, Player* player);
+        void OnPlayerLeaveMapAll(Map* map, Player* player);
+
     public: /* MapScript */
 
         void OnCreateMap(Map* map);
@@ -926,6 +976,12 @@
         bool OnItemRemove(Player* player, Item* item);
         bool OnCastItemCombatSpell(Player* player, Unit* victim, SpellInfo const* spellInfo, Item* item);
 
+    public: /* AllCreatureScript */
+
+        void OnAllCreatureUpdate(Creature* creature, uint32 diff);
+        void Creature_SelectLevel(const CreatureTemplate *cinfo, Creature* creature);
+        void OnCreatureUpdate(Creature* creature, uint32 diff);
+
     public: /* CreatureScript */
 
         CreatureAI* GetCreatureAI(Creature* creature);
@@ -1067,6 +1123,8 @@
         void ModifyMeleeDamage(Unit* target, Unit* attacker, uint32& damage);
         void ModifySpellDamageTaken(Unit* target, Unit* attacker, int32& damage);
         void ModifyVehiclePassengerExitPos(Unit* passenger, Vehicle* vehicle, Position& pos);
+        void ModifyHealRecieved(Unit* target, Unit* attacker, uint32& addHealth);
+        // uint32 DealDamage(Unit* AttackerUnit, Unit *pVictim, uint32 damage, DamageEffectType damagetype);
 
     private:
         uint32 _scriptCount;
Index: src/server/game/World/World.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/server/game/World/World.cpp	(revision 01a1367cfab6a15db39407c3295370fcaa286899)
+++ src/server/game/World/World.cpp	(revision b38f07b8669910b247e3aea4d003b588ba644cb1)
@@ -2129,6 +2129,9 @@
     // Delete all characters which have been deleted X days before
     Player::DeleteOldCharacters();
 
+    TC_LOG_INFO("server.loading", "Loading Autobalance...");
+    sScriptMgr->SetInitialWorldSettings();
+
     TC_LOG_INFO("server.loading", "Initialize AuctionHouseBot...");
     sAuctionBot->Initialize();
 
Index: src/server/scripts/Custom/custom_script_loader.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/server/scripts/Custom/custom_script_loader.cpp	(revision 01a1367cfab6a15db39407c3295370fcaa286899)
+++ src/server/scripts/Custom/custom_script_loader.cpp	(revision 327f90cabe102c734fde7643d35f6531a527f492)
@@ -16,10 +16,12 @@
  */
 
 // This is where scripts' loading functions should be declared:
-
+void AddSC_AutoBalance();
 
 // The name of this function should match:
 // void Add${NameOfDirectory}Scripts()
 void AddCustomScripts()
 {
+    // VAS AutoBalance
+    AddSC_AutoBalance();
 }
Index: src/server/worldserver/worldserver.conf.dist
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/server/worldserver/worldserver.conf.dist	(revision 01a1367cfab6a15db39407c3295370fcaa286899)
+++ src/server/worldserver/worldserver.conf.dist	(revision 48ecde9d63ff31142071422c479690a9cd90b4a6)
@@ -4073,3 +4073,194 @@
 
 #
 ###################################################################################################
+
+###################################################################################################
+#
+# AUTOBALANCE ANNOUNCE
+#
+#     AutoBalanceAnnounce.enable
+#        Announce the module on login
+#        Default:     1 (1 = ON, 0 = OFF)
+
+AutoBalanceAnnounce.enable = 1
+
+#
+# AUTOBALANCE OPTIONS
+#
+#     AutoBalance.enable
+#        Enable/Disable the autobalance system
+#        Default:     1 (1 = ON, 0 = OFF)
+
+AutoBalance.enable = 1
+
+#     AutoBalance.InflectionPoint series
+#        Adjust value of Hyperbolic Tangent function where
+#        the curve of scaling must change. A lower value means higher difficulty.
+#        InflectionPoint & InflectionPointHeroic are the fallback values for 5-man dungeons
+#        InflectionPointRaid10M & InflectionPointRaid10MHeroic are the fallback values for 10 man raids
+#        InflectionPointRaid25M & InflectionPointRaid25MHeroic are the fallback values for 25 man raids
+#        InflectionPointRaid & InflectionPointRaidHeroic are the fallback values for other raids (40-man, 20-man, 15-man, or custom size)
+#        The inflection points fallback to the most specific number
+#
+#        Example: with 0.5 in InflectionPointRaid, a creature of raid (40) will have half of its life with 20 players in
+#                 with 0.8, the same creature will have half of its life with 12 players in
+#
+#        Default:     0.5
+
+AutoBalance.InflectionPoint = 0.5
+AutoBalance.InflectionPointHeroic = 0.5
+
+AutoBalance.InflectionPointRaid10M = 0.5
+AutoBalance.InflectionPointRaid10MHeroic = 0.5
+
+AutoBalance.InflectionPointRaid25M = 0.5
+AutoBalance.InflectionPointRaid25MHeroic = 0.5
+
+AutoBalance.InflectionPointRaid = 0.5
+AutoBalance.InflectionPointRaidHeroic = 0.5
+
+#
+#     AutoBalance.BossInflectionMult
+#        Multiplies the inflection point of bosses, only applies to creatures considered dungeon bosses (from dungeons or raids).
+#        Example: If AutoBalance.BossInflectionMult = 0.4 and AutoBalance.InflectionPoint=0.5, the bosses inflection point will be 0.4*0.9 = 0.36 in a normal dungeon.
+#        Default:     1.0
+
+AutoBalance.BossInflectionMult = 1.0
+
+#
+#     AutoBalance.levelScaling
+#        Check the max level of players in map and scale creature based on it.
+#        This triggers depending on the two options below AutoBalance.levelHigherOffset and AutoBalance.levelLowerOffset
+#        0 = Disabled
+#        1 = Enabled (only in dungeons/raids)
+#        Default:     1
+
+AutoBalance.levelScaling = 0
+
+#
+#     AutoBalance.levelHigherOffset
+#     AutoBalance.levelLowerOffset
+#        Level Offsets between creatures will not be scaled by level.
+#        You can even use it to disable scaling from lower to higher levelScaling
+#        setting levelLowerOffset to 80 (max wotlk level) for example.
+#        default: 3 (higher), 0 (lower)
+
+AutoBalance.levelHigherOffset = 3
+AutoBalance.levelLowerOffset  = 0
+
+#
+#     AutoBalance.levelUseDbValuesWhenExists
+#        When enabled with levelScaling, the creature will use its default database values
+#        instead of level scaling formula when player/party level has correspondance with
+#        creature_template minlevel/maxlevel.
+#
+#        Default:     0 (1 = ON, 0 = OFF)
+
+AutoBalance.levelUseDbValuesWhenExists = 0
+
+#
+#     AutoBalance.LevelEndGameBoost
+#        End game creatures have an exponential (not linear) regression
+#        that is not correctly handled by db values. Keep this enabled
+#        to have stats as near possible to the official ones.
+#
+#        Default:     1 (1 = ON, 0 = OFF)
+
+AutoBalance.LevelEndGameBoost = 1
+
+#
+#     AutoBalance.DungeonScaleDownXP
+#        Decrease individual player's amount of XP gained during a dungeon to match the
+#        amount of XP gained during a full group run. Example: In a 5-man group, you
+#        earn 1/5 of the total XP per kill, but if you solo the dungeon with
+#        AutoBalance.DungeonScaleDownXP = 0, you will earn 5/5 of the total XP.
+#        With the option enabled, you will earn 1/5.
+#        Default:     0 (1 = ON, 0 = OFF)
+
+AutoBalance.DungeonScaleDownXP = 0
+
+#
+#     AutoBalance.DungeonsOnly
+#        Only apply scaling changes to dungeons and raids
+#        Default:     1 (1 = ON, 0 = OFF)
+
+AutoBalance.DungeonsOnly = 1
+
+#
+#     AutoBalance.DebugLevel
+#        0 = None
+#        1 = Errors Only
+#        2 = Errors and Basic Information
+#        3 = All  Info
+#        Default:     2
+
+AutoBalance.DebugLevel = 2
+
+#
+#     AutoBalance.PlayerChangeNotify
+#        Set Auto Notifications to all players in Instance that player count has changed.
+#        Default:     1 (1 = ON, 0 = OFF)
+
+AutoBalance.PlayerChangeNotify = 1
+
+#
+#     AutoBalance.MinHPModifier
+#        Minimum Modifier setting for Health Modification
+#        Default:     0.01
+
+AutoBalance.MinHPModifier = 0.01
+
+#
+#     AutoBalance.MinManaModifier
+#        Minimum Modifier setting for Mana Modification
+#        Default:     0.01
+
+AutoBalance.MinManaModifier = 0.01
+
+#
+#     AutoBalance.MinDamageModifier
+#        Minimum Modifier setting for Damage Modification
+#        Default:     0.01
+
+AutoBalance.MinDamageModifier = 0.01
+
+#
+#     AutoBalance.rate.*
+#        You can tune all rates increasing/decreasing difficulty in a linear way
+#        Note that global rate will increase all other rates. For example:
+#        global = 2.0 , damage = 1.5  -> it means that damage will be 3.0
+#        Default:     1.0
+
+AutoBalance.rate.global = 1.0
+AutoBalance.rate.health = 1.0
+AutoBalance.rate.mana   = 1.0
+AutoBalance.rate.armor  = 1.0
+AutoBalance.rate.damage = 1.0
+
+#
+#     AutoBalance.playerCountDifficultyOffset
+#        Offset of players inside an instance
+#        Default:     0
+
+AutoBalance.playerCountDifficultyOffset = 0
+
+#
+#     AutoBalance.ForcedIDXX
+#        Sets MobIDs for the group they belong to.
+#        All 5 Man Mobs should go in .AutoBalance.5.Name
+#        All 10 Man Mobs should go in .AutoBalance.10.Name etc.
+
+AutoBalance.ForcedID40 = "11583,16441,30057,13020,15589,14435,18192,14889,14888,14887,14890,15302,15818,15742,15741,15740,18338"
+AutoBalance.ForcedID25 = "22997,21966,21965,21964,21806,21215,21845,19728,12397,17711,18256,18192,"
+AutoBalance.ForcedID20 = ""
+AutoBalance.ForcedID10 = "15689,15550,16152,17521,17225,16028,29324,31099"
+AutoBalance.ForcedID5  = "8317,15203,15204,15205,15305,6109,26801,30508,26799,30495,26803,30497,27859,27249"
+AutoBalance.ForcedID2  = ""
+
+#
+#     AutoBalance.DisabledID
+#        Disable scaling on specific creatures
+#
+
+AutoBalance.DisabledID = ""
+###################################################################################################
\ No newline at end of file
Index: src/common/Utilities/DataMap.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/common/Utilities/DataMap.h	(revision e0fb3fec030ad72c174d34331c141ad19bc15930)
+++ src/common/Utilities/DataMap.h	(revision e0fb3fec030ad72c174d34331c141ad19bc15930)
@@ -0,0 +1,68 @@
+/*
+ * Originally written by Rochet2 - Copyright (C) 2018+ AzerothCore <www.azerothcore.org>, released under GNU AGPL v3 license: http://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-AGPL3
+ */
+
+#ifndef _DATA_MAP_H_
+#define _DATA_MAP_H_
+
+#include <string>
+#include <unordered_map>
+#include <memory>
+#include <type_traits>
+
+class DataMap
+{
+public:
+    /**
+     * Base class that you should inherit in your script.
+     * Inheriting classes can be stored to DataMap
+     */
+    class Base
+    {
+    public:
+        virtual ~Base() = default;
+    };
+
+    /**
+     * Returns a pointer to object of requested type stored with given key or nullptr
+     */
+    template<class T> T* Get(std::string const & k) const {
+        static_assert(std::is_base_of<Base, T>::value, "T must derive from Base");
+        if (Container.empty())
+            return nullptr;
+
+        auto it = Container.find(k);
+        if (it != Container.end())
+            return dynamic_cast<T*>(it->second.get());
+        return nullptr;
+    }
+    
+    /**
+     * Returns a pointer to object of requested type stored with given key
+     * or default constructs one and returns that one
+     */
+    template<class T, typename std::enable_if<std::is_default_constructible<T>::value, int>::type = 0>
+    T* GetDefault(std::string const & k) {
+        static_assert(std::is_base_of<Base, T>::value, "T must derive from Base");
+        if (T* v = Get<T>(k))
+            return v;
+        T* v = new T();
+        Container.emplace(k, std::unique_ptr<T>(v));
+        return v;
+    }
+    
+    /**
+     * Stores a new object that inherits the Base class with the given key
+     */
+    void Set(std::string const & k, Base* v) { Container[k] = std::unique_ptr<Base>(v); }
+
+    /**
+     * Removes objects with given key and returns true if one was removed, false otherwise
+     */
+    bool Erase(std::string const & k) { return Container.erase(k) != 0; }
+
+private:
+    std::unordered_map<std::string, std::unique_ptr<Base>> Container;
+};
+
+#endif
Index: src/server/game/Entities/Object/Object.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/server/game/Entities/Object/Object.h	(revision b38f07b8669910b247e3aea4d003b588ba644cb1)
+++ src/server/game/Entities/Object/Object.h	(revision e0fb3fec030ad72c174d34331c141ad19bc15930)
@@ -19,6 +19,7 @@
 #define _OBJECT_H
 
 #include "Common.h"
+#include "DataMap.h"
 #include "Duration.h"
 #include "EventProcessor.h"
 #include "GridReference.h"
@@ -188,6 +189,7 @@
 
         virtual std::string GetDebugInfo() const;
 
+        DataMap CustomData;
     protected:
         Object();
 
Index: src/server/game/Maps/Map.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/server/game/Maps/Map.h	(revision b38f07b8669910b247e3aea4d003b588ba644cb1)
+++ src/server/game/Maps/Map.h	(revision e0fb3fec030ad72c174d34331c141ad19bc15930)
@@ -32,6 +32,7 @@
 #include "SpawnData.h"
 #include "Timer.h"
 #include "Transaction.h"
+#include "DataMap.h"
 #include <boost/heap/fibonacci_heap.hpp>
 #include <bitset>
 #include <list>
@@ -644,6 +645,7 @@
 
         virtual std::string GetDebugInfo() const;
 
+        DataMap CustomData;
     private:
         void LoadMapAndVMap(int gx, int gy);
         void LoadVMap(int gx, int gy);
Index: src/server/scripts/Custom/AutoBalance.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/server/scripts/Custom/AutoBalance.cpp	(revision 3ba45ad48bcdcd874253d3da968b36bfff9b0b3d)
+++ src/server/scripts/Custom/AutoBalance.cpp	(revision 3ba45ad48bcdcd874253d3da968b36bfff9b0b3d)
@@ -0,0 +1,779 @@
+/*
+* Copyright (C) 2012 CVMagic <http://www.trinitycore.org/f/topic/6551-vas-autobalance/>
+* Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+* Copyright (C) 2006-2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+* Copyright (C) 1985-2010 {VAS} KalCorp  <http://vasserver.dyndns.org/>
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2 of the License, or (at your
+* option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/*
+* Script Name: AutoBalance
+* Original Authors: KalCorp and Vaughner
+* Maintainer(s): CVMagic
+* Original Script Name: VAS.AutoBalance
+* Description: This script is intended to scale based on number of players, instance mobs & world bosses' health, mana, and damage.
+*/
+
+
+#include "Configuration/Config.h"
+#include "Unit.h"
+#include "Chat.h"
+#include "Creature.h"
+#include "Player.h"
+#include "ObjectMgr.h"
+#include "MapManager.h"
+#include "World.h"
+#include "Map.h"
+#include "ScriptMgr.h"
+#include "Language.h"
+#include <vector>
+#include "Log.h"
+#include "Group.h"
+#include "DataMap.h"
+#include "DBCStores.h"
+
+class AutoBalanceCreatureInfo : public DataMap::Base {
+public:
+    AutoBalanceCreatureInfo() {}
+
+    AutoBalanceCreatureInfo(uint32 count, float dmg, float hpRate, float manaRate, float armorRate, uint8 selLevel) :
+            instancePlayerCount(count), selectedLevel(selLevel), DamageMultiplier(dmg), HealthMultiplier(hpRate), ManaMultiplier(manaRate),
+            ArmorMultiplier(armorRate) {}
+
+    uint32 instancePlayerCount = 0;
+    uint8 selectedLevel = 0;
+    // this is used to detect creatures that update their entry
+    uint32 entry = 0;
+    float DamageMultiplier = 1;
+    float HealthMultiplier = 1;
+    float ManaMultiplier = 1;
+    float ArmorMultiplier = 1;
+};
+
+class AutoBalanceMapInfo : public DataMap::Base {
+public:
+    AutoBalanceMapInfo() {}
+
+    AutoBalanceMapInfo(uint32 count, uint8 selLevel) : playerCount(count), mapLevel(selLevel) {}
+
+    uint32 playerCount = 0;
+    uint8 mapLevel = 0;
+};
+
+// The map values correspond with the .AutoBalance.XX.Name entries in the configuration file.
+static std::map<int, int> forcedCreatureIds;
+static int8 PlayerCountDifficultyOffset, LevelScaling, higherOffset, lowerOffset;
+static bool enabled, LevelEndGameBoost, DungeonsOnly, PlayerChangeNotify, LevelUseDb, DungeonScaleDownXP;
+static float globalRate, healthMultiplier, manaMultiplier, armorMultiplier, damageMultiplier, MinHPModifier, MinManaModifier, MinDamageModifier,
+        InflectionPoint, InflectionPointRaid, InflectionPointRaid10M, InflectionPointRaid25M, InflectionPointHeroic, InflectionPointRaidHeroic,
+        InflectionPointRaid10MHeroic, InflectionPointRaid25MHeroic, BossInflectionMult;
+
+int GetValidDebugLevel() {
+    int debugLevel = sConfigMgr->GetIntDefault("AutoBalance.DebugLevel", 2);
+    if ((debugLevel < 0) || (debugLevel > 3)) {
+        return 1;
+    }
+    return debugLevel;
+}
+
+// Used for reading the string from the configuration file to for those creatures who need to be scaled for XX number of players.
+void LoadForcedCreatureIdsFromString(std::string creatureIds, int forcedPlayerCount) {
+    std::string delimitedValue;
+    std::stringstream creatureIdsStream;
+
+    creatureIdsStream.str(creatureIds);
+    // Process each Creature ID in the string, delimited by the comma - ","
+    while (std::getline(creatureIdsStream, delimitedValue, ',')) {
+        int creatureId = atoi(delimitedValue.c_str());
+        if (creatureId >= 0) {
+            forcedCreatureIds[creatureId] = forcedPlayerCount;
+        }
+    }
+}
+
+int GetForcedNumPlayers(int creatureId) {
+    // Don't want the forcedCreatureIds map to blowup to a massive empty array
+    if (forcedCreatureIds.find(creatureId) == forcedCreatureIds.end()) {
+        return -1;
+    }
+    return forcedCreatureIds[creatureId];
+}
+
+void getAreaLevel(Map *map, uint8 areaid, uint8 &min, uint8 &max) {
+    LFGDungeonEntry const *dungeon = GetLFGDungeon(map->GetId(), map->GetDifficulty());
+    if (dungeon && (map->IsDungeon() || map->IsRaid())) {
+        min = dungeon->MinLevel;
+        max = dungeon->TargetLevel ? dungeon->TargetLevel : dungeon->MaxLevel;
+    }
+
+    if (!min && !max) {
+        AreaTableEntry const *areaEntry = sAreaTableStore.LookupEntry(areaid);
+        if (areaEntry && areaEntry->ExplorationLevel > 0) {
+            min = areaEntry->ExplorationLevel;
+            max = areaEntry->ExplorationLevel;
+        }
+    }
+}
+
+class AutoBalance_WorldScript : public WorldScript {
+public:
+    AutoBalance_WorldScript() : WorldScript("AutoBalance_WorldScript") {
+    }
+
+    void OnConfigLoad(bool reload) override {
+        SetInitialWorldSettings();
+    }
+
+    void OnStartup() override {
+    }
+
+    void SetInitialWorldSettings() {
+        forcedCreatureIds.clear();
+        LoadForcedCreatureIdsFromString(sConfigMgr->GetStringDefault("AutoBalance.ForcedID40", ""), 40);
+        LoadForcedCreatureIdsFromString(sConfigMgr->GetStringDefault("AutoBalance.ForcedID25", ""), 25);
+        LoadForcedCreatureIdsFromString(sConfigMgr->GetStringDefault("AutoBalance.ForcedID10", ""), 10);
+        LoadForcedCreatureIdsFromString(sConfigMgr->GetStringDefault("AutoBalance.ForcedID5", ""), 5);
+        LoadForcedCreatureIdsFromString(sConfigMgr->GetStringDefault("AutoBalance.ForcedID2", ""), 2);
+        LoadForcedCreatureIdsFromString(sConfigMgr->GetStringDefault("AutoBalance.DisabledID", ""), 0);
+
+        enabled = sConfigMgr->GetBoolDefault("AutoBalance.enable", 1);
+        LevelEndGameBoost = sConfigMgr->GetBoolDefault("AutoBalance.LevelEndGameBoost", 1);
+        DungeonsOnly = sConfigMgr->GetBoolDefault("AutoBalance.DungeonsOnly", 1);
+        PlayerChangeNotify = sConfigMgr->GetBoolDefault("AutoBalance.PlayerChangeNotify", 1);
+        LevelUseDb = sConfigMgr->GetBoolDefault("AutoBalance.levelUseDbValuesWhenExists", 1);
+        DungeonScaleDownXP = sConfigMgr->GetBoolDefault("AutoBalance.DungeonScaleDownXP", 0);
+
+        LevelScaling = sConfigMgr->GetIntDefault("AutoBalance.levelScaling", 1);
+        PlayerCountDifficultyOffset = sConfigMgr->GetIntDefault("AutoBalance.playerCountDifficultyOffset", 0);
+        higherOffset = sConfigMgr->GetIntDefault("AutoBalance.levelHigherOffset", 3);
+        lowerOffset = sConfigMgr->GetIntDefault("AutoBalance.levelLowerOffset", 0);
+
+        InflectionPoint = sConfigMgr->GetFloatDefault("AutoBalance.InflectionPoint", 0.5f);
+        InflectionPointRaid = sConfigMgr->GetFloatDefault("AutoBalance.InflectionPointRaid", InflectionPoint);
+        InflectionPointRaid25M = sConfigMgr->GetFloatDefault("AutoBalance.InflectionPointRaid25M", InflectionPointRaid);
+        InflectionPointRaid10M = sConfigMgr->GetFloatDefault("AutoBalance.InflectionPointRaid10M", InflectionPointRaid);
+        InflectionPointHeroic = sConfigMgr->GetFloatDefault("AutoBalance.InflectionPointHeroic", InflectionPoint);
+        InflectionPointRaidHeroic = sConfigMgr->GetFloatDefault("AutoBalance.InflectionPointRaidHeroic", InflectionPointRaid);
+        InflectionPointRaid25MHeroic = sConfigMgr->GetFloatDefault("AutoBalance.InflectionPointRaid25MHeroic", InflectionPointRaid25M);
+        InflectionPointRaid10MHeroic = sConfigMgr->GetFloatDefault("AutoBalance.InflectionPointRaid10MHeroic", InflectionPointRaid10M);
+        BossInflectionMult = sConfigMgr->GetFloatDefault("AutoBalance.BossInflectionMult", 1.0f);
+        globalRate = sConfigMgr->GetFloatDefault("AutoBalance.rate.global", 1.0f);
+        healthMultiplier = sConfigMgr->GetFloatDefault("AutoBalance.rate.health", 1.0f);
+        manaMultiplier = sConfigMgr->GetFloatDefault("AutoBalance.rate.mana", 1.0f);
+        armorMultiplier = sConfigMgr->GetFloatDefault("AutoBalance.rate.armor", 1.0f);
+        damageMultiplier = sConfigMgr->GetFloatDefault("AutoBalance.rate.damage", 1.0f);
+        MinHPModifier = sConfigMgr->GetFloatDefault("AutoBalance.MinHPModifier", 0.1f);
+        MinManaModifier = sConfigMgr->GetFloatDefault("AutoBalance.MinManaModifier", 0.1f);
+        MinDamageModifier = sConfigMgr->GetFloatDefault("AutoBalance.MinDamageModifier", 0.1f);
+    }
+};
+
+class AutoBalance_PlayerScript : public PlayerScript {
+public:
+    AutoBalance_PlayerScript() : PlayerScript("AutoBalance_PlayerScript") {
+    }
+
+    void OnLogin(Player *Player, bool firstLogin) override {
+        if (sConfigMgr->GetBoolDefault("AutoBalanceAnnounce.enable", true)) {
+            ChatHandler(Player->GetSession()).SendSysMessage("This server is running the |cff4CFF00AutoBalance |rmodule.");
+        }
+    }
+
+    virtual void OnLevelChanged(Player *player, uint8 /*oldlevel*/) override {
+        if (!enabled || !player) {
+            return;
+        }
+
+        if (LevelScaling == 0) {
+            return;
+        }
+
+        AutoBalanceMapInfo *mapABInfo = player->GetMap()->CustomData.GetDefault<AutoBalanceMapInfo>("AutoBalanceMapInfo");
+        if (mapABInfo->mapLevel < player->GetLevel()) {
+            mapABInfo->mapLevel = player->GetLevel();
+        }
+    }
+
+    void OnGiveXP(Player *player, uint32 &amount, Unit *victim) override {
+        if (victim && DungeonScaleDownXP) {
+            Map *map = player->GetMap();
+
+            if (map->IsDungeon()) {
+                // Ensure that the players always get the same XP, even when entering the dungeon alone
+                uint32 maxPlayerCount = ((InstanceMap *) sMapMgr->FindMap(map->GetId(), map->GetInstanceId()))->GetMaxPlayers();
+                uint32 currentPlayerCount = map->GetPlayersCountExceptGMs();
+                amount *= (float) currentPlayerCount / maxPlayerCount;
+            }
+        }
+    }
+};
+
+class AutoBalance_UnitScript : public UnitScript {
+public:
+    AutoBalance_UnitScript() : UnitScript("AutoBalance_UnitScript") {
+    }
+
+//    uint32 DealDamage(Unit *AttackerUnit, Unit *playerVictim, uint32 damage, DamageEffectType /*damagetype*/) {
+//        return _Modifer_DealDamage(playerVictim, AttackerUnit, damage);
+//    }
+
+    void ModifyPeriodicDamageAurasTick(Unit *target, Unit *attacker, uint32 &damage) override {
+        damage = _Modifer_DealDamage(target, attacker, damage);
+    }
+
+    void ModifySpellDamageTaken(Unit *target, Unit *attacker, int32 &damage) override {
+        damage = _Modifer_DealDamage(target, attacker, damage);
+    }
+
+    void ModifyMeleeDamage(Unit *target, Unit *attacker, uint32 &damage) override {
+        damage = _Modifer_DealDamage(target, attacker, damage);
+    }
+
+    void ModifyHealRecieved(Unit *target, Unit *attacker, uint32 &damage) override {
+        damage = _Modifer_DealDamage(target, attacker, damage);
+    }
+
+    uint32 _Modifer_DealDamage(Unit *target, Unit *attacker, uint32 damage) {
+        if (!enabled) {
+            return damage;
+        }
+
+        if (!attacker || attacker->GetTypeId() == TYPEID_PLAYER || !attacker->IsInWorld()) {
+            return damage;
+        }
+
+        float damageMultiplier = attacker->CustomData.GetDefault<AutoBalanceCreatureInfo>("AutoBalanceCreatureInfo")->DamageMultiplier;
+        if (damageMultiplier == 1) {
+            return damage;
+        }
+
+        if (!(!DungeonsOnly || (target->GetMap()->IsDungeon() && attacker->GetMap()->IsDungeon())
+              || (attacker->GetMap()->IsBattleground() && target->GetMap()->IsBattleground()))) {
+            return damage;
+        }
+
+        if ((attacker->IsHunterPet() || attacker->IsPet() || attacker->IsSummon()) && attacker->IsControlledByPlayer()) {
+            return damage;
+        }
+
+        return damage * damageMultiplier;
+    }
+};
+
+class AutoBalance_AllMapScript : public AllMapScript {
+public:
+    AutoBalance_AllMapScript() : AllMapScript("AutoBalance_AllMapScript") {
+    }
+
+    void OnPlayerEnterAll(Map *map, Player *player) {
+        if (!enabled) {
+            return;
+        }
+
+        if (player->IsGameMaster()) {
+            return;
+        }
+
+        AutoBalanceMapInfo *mapABInfo = map->CustomData.GetDefault<AutoBalanceMapInfo>("AutoBalanceMapInfo");
+        // always check level, even if not conf enabled
+        // because we can enable at runtime and we need this information
+        if (player) {
+            if (player->GetLevel() > mapABInfo->mapLevel) {
+                mapABInfo->mapLevel = player->GetLevel();
+            }
+        } else {
+            Map::PlayerList const &playerList = map->GetPlayers();
+            if (!playerList.isEmpty()) {
+                for (Map::PlayerList::const_iterator playerIteration = playerList.begin(); playerIteration != playerList.end(); ++playerIteration) {
+                    if (Player * playerHandle = playerIteration->GetSource()) {
+                        if (!playerHandle->IsGameMaster() && playerHandle->GetLevel() > mapABInfo->mapLevel) {
+                            mapABInfo->mapLevel = playerHandle->GetLevel();
+                        }
+                    }
+                }
+            }
+        }
+
+        mapABInfo->playerCount++; //(maybe we've to found a safe solution to avoid player recount each time)
+        //mapABInfo->playerCount = map->GetPlayersCountExceptGMs();
+
+        if (PlayerChangeNotify) {
+            if (map->GetEntry()->IsDungeon() && player) {
+                Map::PlayerList const &playerList = map->GetPlayers();
+                if (!playerList.isEmpty()) {
+                    for (Map::PlayerList::const_iterator playerIteration = playerList.begin(); playerIteration != playerList.end(); ++playerIteration) {
+                        if (Player * playerHandle = playerIteration->GetSource()) {
+                            ChatHandler chatHandle = ChatHandler(playerHandle->GetSession());
+                            chatHandle.PSendSysMessage("|cffFF0000 [AutoBalance]|r|cffFF8000 %s entered the Instance %s. Auto setting player count to %u (Player Difficulty Offset = %u) |r",
+                                                       player->GetName().c_str(), map->GetMapName(), mapABInfo->playerCount + PlayerCountDifficultyOffset, PlayerCountDifficultyOffset);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    void OnPlayerLeaveAll(Map *map, Player *player) {
+        if (!enabled) {
+            return;
+        }
+
+        if (player->IsGameMaster()) {
+            return;
+        }
+
+        AutoBalanceMapInfo *mapABInfo = map->CustomData.GetDefault<AutoBalanceMapInfo>("AutoBalanceMapInfo");
+        // (maybe we've to found a safe solution to avoid player recount each time)
+        mapABInfo->playerCount--;
+        // mapABInfo->playerCount = map->GetPlayersCountExceptGMs();
+
+        // always check level, even if not conf enabled
+        // because we can enable at runtime and we need this information
+        if (!mapABInfo->playerCount) {
+            mapABInfo->mapLevel = 0;
+            return;
+        }
+
+        if (PlayerChangeNotify) {
+            if (map->GetEntry()->IsDungeon() && player) {
+                Map::PlayerList const &playerList = map->GetPlayers();
+                if (!playerList.isEmpty()) {
+                    for (Map::PlayerList::const_iterator playerIteration = playerList.begin(); playerIteration != playerList.end(); ++playerIteration) {
+                        if (Player * playerHandle = playerIteration->GetSource()) {
+                            ChatHandler chatHandle = ChatHandler(playerHandle->GetSession());
+                            chatHandle.PSendSysMessage("|cffFF0000 [-AutoBalance]|r|cffFF8000 %s left the Instance %s. Auto setting player count to %u (Player Difficulty Offset = %u) |r",
+                                                       player->GetName().c_str(), map->GetMapName(), mapABInfo->playerCount, PlayerCountDifficultyOffset);
+                        }
+                    }
+                }
+            }
+        }
+    }
+};
+
+class AutoBalance_AllCreatureScript : public AllCreatureScript {
+public:
+    AutoBalance_AllCreatureScript()
+            : AllCreatureScript("AutoBalance_AllCreatureScript") {
+    }
+
+    void Creature_SelectLevel(const CreatureTemplate * /*creatureTemplate*/, Creature *creature) override {
+        if (!enabled) {
+            return;
+        }
+        ModifyCreatureAttributes(creature, true);
+    }
+
+    void OnAllCreatureUpdate(Creature *creature, uint32 /*diff*/) override {
+        if (!enabled) {
+            return;
+        }
+        ModifyCreatureAttributes(creature);
+    }
+
+    bool checkLevelOffset(uint8 selectedLevel, uint8 targetLevel) {
+        return selectedLevel && ((targetLevel >= selectedLevel && targetLevel <= (selectedLevel + higherOffset)) ||
+                                 (targetLevel <= selectedLevel && targetLevel >= (selectedLevel - lowerOffset)));
+    }
+
+    void ModifyCreatureAttributes(Creature *creature, bool resetSelLevel = false) {
+        if (!creature || !creature->GetMap()) {
+            return;
+        }
+
+        if (!creature->GetMap()->IsDungeon() && !creature->GetMap()->IsBattleground() && DungeonsOnly) {
+            return;
+        }
+
+        if (((creature->IsHunterPet() || creature->IsPet() || creature->IsSummon()) && creature->IsControlledByPlayer())) {
+            return;
+        }
+
+        AutoBalanceMapInfo *mapABInfo = creature->GetMap()->CustomData.GetDefault<AutoBalanceMapInfo>("AutoBalanceMapInfo");
+        if (!mapABInfo->mapLevel) {
+            return;
+        }
+
+        CreatureTemplate const *creatureTemplate = creature->GetCreatureTemplate();
+        InstanceMap *instanceMap = ((InstanceMap *) sMapMgr->FindMap(creature->GetMapId(), creature->GetInstanceId()));
+        uint32 maxNumberOfPlayers = instanceMap->GetMaxPlayers();
+        int forcedNumPlayers = GetForcedNumPlayers(creatureTemplate->Entry);
+
+        if (forcedNumPlayers > 0) {
+            // Force maxNumberOfPlayers to be changed to match the Configuration entries ForcedID2, ForcedID5, ForcedID10, ForcedID20, ForcedID25, ForcedID40
+            maxNumberOfPlayers = forcedNumPlayers;
+        } else if (forcedNumPlayers == 0) {
+            // forcedNumPlayers 0 means that the creature is contained in DisabledID -> no scaling
+            return;
+        }
+
+        AutoBalanceCreatureInfo *creatureABInfo = creature->CustomData.GetDefault<AutoBalanceCreatureInfo>("AutoBalanceCreatureInfo");
+        // force resetting selected level.
+        // this is also a "workaround" to fix bug of not recalculated
+        // attributes when UpdateEntry has been used.
+        // TODO: It's better and faster to implement a core hook
+        // in that position and force a recalculation then
+        if ((creatureABInfo->entry != 0 && creatureABInfo->entry != creature->GetEntry()) || resetSelLevel) {
+            // force a recalculation
+            creatureABInfo->selectedLevel = 0;
+        }
+
+        if (!creature->IsAlive()) {
+            return;
+        }
+
+        uint32 curCount = mapABInfo->playerCount + PlayerCountDifficultyOffset;
+        uint8 bonusLevel = creatureTemplate->rank == CREATURE_ELITE_WORLDBOSS ? 3 : 0;
+
+        // already scaled
+        if (creatureABInfo->selectedLevel > 0) {
+            if (LevelScaling) {
+                if (checkLevelOffset(mapABInfo->mapLevel + bonusLevel, creature->GetLevel()) &&
+                    checkLevelOffset(creatureABInfo->selectedLevel, creature->GetLevel()) &&
+                    creatureABInfo->instancePlayerCount == curCount) {
+                    return;
+                }
+            } else if (creatureABInfo->instancePlayerCount == curCount) {
+                return;
+            }
+        }
+
+        creatureABInfo->instancePlayerCount = curCount;
+        // no players in map, do not modify attributes
+        if (!creatureABInfo->instancePlayerCount) {
+            return;
+        }
+
+        uint8 originalLevel = creatureTemplate->maxlevel;
+        uint8 level = mapABInfo->mapLevel;
+        uint8 areaMinLvl, areaMaxLvl;
+        getAreaLevel(creature->GetMap(), creature->GetAreaId(), areaMinLvl, areaMaxLvl);
+
+        // avoid level changing for critters and special creatures (spell summons etc.) in instances
+        bool skipLevel = false;
+        if (originalLevel <= 1 && areaMinLvl >= 5) {
+            skipLevel = true;
+        }
+
+        if (LevelScaling && creature->GetMap()->IsDungeon() && !skipLevel && !checkLevelOffset(level, originalLevel)) {
+            // change level only whithin the offsets and when in dungeon/raid
+            if (level != creatureABInfo->selectedLevel || creatureABInfo->selectedLevel != creature->GetLevel()) {
+                // keep bosses +3 level
+                creatureABInfo->selectedLevel = level + bonusLevel;
+                creature->SetLevel(creatureABInfo->selectedLevel);
+            }
+        } else {
+            creatureABInfo->selectedLevel = creature->GetLevel();
+        }
+
+        creatureABInfo->entry = creature->GetEntry();
+        bool useDefStats = false;
+        if (LevelUseDb && creature->GetLevel() >= creatureTemplate->minlevel && creature->GetLevel() <= creatureTemplate->maxlevel) {
+            useDefStats = true;
+        }
+
+        CreatureBaseStats const *origCreatureStats = sObjectMgr->GetCreatureBaseStats(originalLevel, creatureTemplate->unit_class);
+        CreatureBaseStats const *creatureStats = sObjectMgr->GetCreatureBaseStats(creatureABInfo->selectedLevel, creatureTemplate->unit_class);
+
+        uint32 baseHealth = origCreatureStats->GenerateHealth(creatureTemplate);
+        uint32 baseMana = origCreatureStats->GenerateMana(creatureTemplate);
+        uint32 scaledHealth = 0;
+        uint32 scaledMana = 0;
+
+        // Note: InflectionPoint handle the number of players required to get 50% health.
+        //       you'd adjust this to raise or lower the hp modifier for per additional player in a non-whole group.
+        //
+        //       diff modify the rate of percentage increase between
+        //       number of players. Generally the closer to the value of 1 you have this
+        //       the less gradual the rate will be. For example in a 5 man it would take 3
+        //       total players to face a mob at full health.
+        //
+        //       The +1 and /2 values raise the TanH function to a positive range and make
+        //       sure the modifier never goes above the value or 1.0 or below 0.
+        //
+        float defaultMultiplier = 1.0f;
+        if (creatureABInfo->instancePlayerCount < maxNumberOfPlayers) {
+            float inflectionValue = (float) maxNumberOfPlayers;
+
+            if (instanceMap->IsHeroic()) {
+                if (instanceMap->IsRaid()) {
+                    switch (instanceMap->GetMaxPlayers()) {
+                        case 10:
+                            inflectionValue *= InflectionPointRaid10MHeroic;
+                            break;
+                        case 25:
+                            inflectionValue *= InflectionPointRaid25MHeroic;
+                            break;
+                        default:
+                            inflectionValue *= InflectionPointRaidHeroic;
+                    }
+                } else {
+                    inflectionValue *= InflectionPointHeroic;
+                }
+            } else {
+                if (instanceMap->IsRaid()) {
+                    switch (instanceMap->GetMaxPlayers()) {
+                        case 10:
+                            inflectionValue *= InflectionPointRaid10M;
+                            break;
+                        case 25:
+                            inflectionValue *= InflectionPointRaid25M;
+                            break;
+                        default:
+                            inflectionValue *= InflectionPointRaid;
+                    }
+                } else {
+                    inflectionValue *= InflectionPoint;
+                }
+            }
+            if (creature->IsDungeonBoss()) {
+                inflectionValue *= BossInflectionMult;
+            }
+
+            float diff = ((float) maxNumberOfPlayers / 5) * 1.5f;
+            defaultMultiplier = (tanh(((float) creatureABInfo->instancePlayerCount - inflectionValue) / diff) + 1.0f) / 2.0f;
+        }
+
+        creatureABInfo->HealthMultiplier = healthMultiplier * defaultMultiplier * globalRate;
+
+        if (creatureABInfo->HealthMultiplier <= MinHPModifier) {
+            creatureABInfo->HealthMultiplier = MinHPModifier;
+        }
+
+        float hpStatsRate = 1.0f;
+        if (!useDefStats && LevelScaling && !skipLevel) {
+            float newBaseHealth = 0;
+            if (level <= 60) {
+                newBaseHealth = creatureStats->BaseHealth[0];
+            } else if (level <= 70) {
+                newBaseHealth = creatureStats->BaseHealth[1];
+            } else {
+                newBaseHealth = creatureStats->BaseHealth[2];
+                // special increasing for end-game contents
+                if (LevelEndGameBoost) {
+                    newBaseHealth *= creatureABInfo->selectedLevel >= 75 && originalLevel < 75 ? float(creatureABInfo->selectedLevel - 70) * 0.3f : 1;
+                }
+            }
+
+            float newHealth = newBaseHealth * creatureTemplate->ModHealth;
+            // allows health to be different with creatures that originally
+            // differentiate their health by different level instead of multiplier field.
+            // expecially in dungeons. The health reduction decrease if original level is similar to the area max level
+            if (originalLevel >= areaMinLvl && originalLevel < areaMaxLvl) {
+                // never more than 30%
+                float reduction = newHealth / float(areaMaxLvl - areaMinLvl) * (float(areaMaxLvl - originalLevel) * 0.3f);
+                if (reduction > 0 && reduction < newHealth) {
+                    newHealth -= reduction;
+                }
+            }
+            hpStatsRate = newHealth / float(baseHealth);
+        }
+
+        creatureABInfo->HealthMultiplier *= hpStatsRate;
+        scaledHealth = round(((float) baseHealth * creatureABInfo->HealthMultiplier) + 1.0f);
+
+        // Getting the list of Classes in this group
+        // This will be used later on to determine what additional scaling will be required based on the ratio of tank/dps/healer
+        // Update playerClassList with the list of all the participating Classes
+        // GetPlayerClassList(creature, playerClassList);
+
+        float manaStatsRate = 1.0f;
+        if (!useDefStats && LevelScaling && !skipLevel) {
+            float newMana = creatureStats->GenerateMana(creatureTemplate);
+            manaStatsRate = newMana / float(baseMana);
+        }
+
+        creatureABInfo->ManaMultiplier = manaStatsRate * manaMultiplier * defaultMultiplier * globalRate;
+        if (creatureABInfo->ManaMultiplier <= MinManaModifier) {
+            creatureABInfo->ManaMultiplier = MinManaModifier;
+        }
+
+        scaledMana = round(baseMana * creatureABInfo->ManaMultiplier);
+        float damageMul = defaultMultiplier * globalRate * damageMultiplier;
+        // Can not be less then Min_D_Mod
+        if (damageMul <= MinDamageModifier) {
+            damageMul = MinDamageModifier;
+        }
+
+        if (!useDefStats && LevelScaling && !skipLevel) {
+            float origDmgBase = origCreatureStats->GenerateBaseDamage(creatureTemplate);
+            float newDmgBase = 0;
+            if (level <= 60) {
+                newDmgBase = creatureStats->BaseDamage[0];
+            } else if (level <= 70) {
+                newDmgBase = creatureStats->BaseDamage[1];
+            } else {
+                newDmgBase = creatureStats->BaseDamage[2];
+                // special increasing for end-game contents
+                if (LevelEndGameBoost && !creature->GetMap()->IsRaid())
+                    newDmgBase *= creatureABInfo->selectedLevel >= 75 && originalLevel < 75 ? float(creatureABInfo->selectedLevel - 70) * 0.3f : 1;
+            }
+
+            damageMul *= newDmgBase / origDmgBase;
+        }
+
+        creatureABInfo->ArmorMultiplier = defaultMultiplier * globalRate * armorMultiplier;
+        uint32 newBaseArmor = round(creatureABInfo->ArmorMultiplier *
+                                    ((useDefStats || !LevelScaling || skipLevel) ? origCreatureStats->GenerateArmor(creatureTemplate)
+                                                                                 : creatureStats->GenerateArmor(creatureTemplate)));
+        uint32 prevMaxHealth = creature->GetMaxHealth();
+        uint32 prevMaxPower = creature->GetMaxPower(POWER_MANA);
+        uint32 prevHealth = creature->GetHealth();
+        uint32 prevPower = creature->GetPower(POWER_MANA);
+        Powers pType = creature->GetPowerType();
+
+        creature->SetArmor(newBaseArmor);
+        creature->SetStatFlatModifier(UNIT_MOD_ARMOR, BASE_VALUE, (float) newBaseArmor);
+        creature->SetCreateHealth(scaledHealth);
+        creature->SetMaxHealth(scaledHealth);
+        creature->ResetPlayerDamageReq();
+        creature->SetCreateMana(scaledMana);
+        creature->SetMaxPower(POWER_MANA, scaledMana);
+        creature->SetStatFlatModifier(UNIT_MOD_ENERGY, BASE_VALUE, (float) 100.0f);
+        creature->SetStatFlatModifier(UNIT_MOD_RAGE, BASE_VALUE, (float) 100.0f);
+        creature->SetStatFlatModifier(UNIT_MOD_HEALTH, BASE_VALUE, (float) scaledHealth);
+        creature->SetStatFlatModifier(UNIT_MOD_MANA, BASE_VALUE, (float) scaledMana);
+        creatureABInfo->DamageMultiplier = damageMul;
+
+        uint32 scaledCurHealth = prevHealth && prevMaxHealth ? float(scaledHealth) / float(prevMaxHealth) * float(prevHealth) : 0;
+        uint32 scaledCurPower = prevPower && prevMaxPower ? float(scaledMana) / float(prevMaxPower) * float(prevPower) : 0;
+
+        creature->SetHealth(scaledCurHealth);
+        if (pType == POWER_MANA) {
+            creature->SetPower(POWER_MANA, scaledCurPower);
+        } else {
+            // fix creatures with different power types
+            creature->SetPowerType(pType);
+        }
+        creature->UpdateAllStats();
+    }
+};
+
+class AutoBalance_CommandScript : public CommandScript {
+public:
+    AutoBalance_CommandScript() : CommandScript("AutoBalance_CommandScript") {}
+
+    std::vector <ChatCommand> GetCommands() const {
+        static std::vector <ChatCommand> ABCommandTable =
+                {
+                        {"setoffset", SEC_GAMEMASTER, true, &HandleABSetOffsetCommand,     "Sets the global Player Difficulty Offset for instances. Example: (You + offset(1) = 2 player difficulty)."},
+                        {"getoffset", SEC_GAMEMASTER, true, &HandleABGetOffsetCommand,     "Shows current global player offset value"},
+                        {"checkmap",  SEC_GAMEMASTER, true, &HandleABCheckMapCommand,      "Run a check for current map/instance, it can help in case you're testing autobalance with GM."},
+                        {"mapstat",   SEC_GAMEMASTER, true, &HandleABMapStatsCommand,      "Shows current autobalance information for this map-"},
+                        {"crstat",    SEC_GAMEMASTER, true, &HandleABCreatureStatsCommand, "Shows current autobalance information for selected creature."},
+                };
+
+        static std::vector <ChatCommand> commandTable =
+                {
+                        {"vas", SEC_GAMEMASTER, false, NULL, "", ABCommandTable},
+                };
+        return commandTable;
+    }
+
+    static bool HandleABSetOffsetCommand(ChatHandler *handler, const char *args) {
+        if (!*args) {
+            handler->PSendSysMessage(".vas setoffset #");
+            handler->PSendSysMessage("Sets the Player Difficulty Offset for instances. Example: (You + offset(1) = 2 player difficulty).");
+            return false;
+        }
+        char *offset = strtok((char *) args, " ");
+        int32 offseti = -1;
+
+        if (offset) {
+            offseti = (uint32) atoi(offset);
+            handler->PSendSysMessage("Changing Player Difficulty Offset to %i.", offseti);
+            PlayerCountDifficultyOffset = offseti;
+            return true;
+        } else {
+            handler->PSendSysMessage("Error changing Player Difficulty Offset! Please try again.");
+        }
+        return false;
+    }
+
+    static bool HandleABGetOffsetCommand(ChatHandler *handler, const char * /*args*/) {
+        handler->PSendSysMessage("Current Player Difficulty Offset = %i", PlayerCountDifficultyOffset);
+        return true;
+    }
+
+    static bool HandleABCheckMapCommand(ChatHandler *handler, const char *args) {
+        Player *pl = handler->getSelectedPlayer();
+
+        if (!pl) {
+            handler->SendSysMessage(LANG_SELECT_PLAYER_OR_PET);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        AutoBalanceMapInfo *mapABInfo = pl->GetMap()->CustomData.GetDefault<AutoBalanceMapInfo>("AutoBalanceMapInfo");
+        mapABInfo->playerCount = pl->GetMap()->GetPlayersCountExceptGMs();
+
+        Map::PlayerList const &playerList = pl->GetMap()->GetPlayers();
+        uint8 level = 0;
+        if (!playerList.isEmpty()) {
+            for (Map::PlayerList::const_iterator playerIteration = playerList.begin();
+                 playerIteration != playerList.end(); ++playerIteration) {
+                if (Player * playerHandle = playerIteration->GetSource()) {
+                    if (playerHandle->GetLevel() > level) {
+                        mapABInfo->mapLevel = level = playerHandle->GetLevel();
+                    }
+                }
+            }
+        }
+        HandleABMapStatsCommand(handler, args);
+        return true;
+    }
+
+    static bool HandleABMapStatsCommand(ChatHandler *handler, const char * /*args*/) {
+        Player *pl = handler->getSelectedPlayer();
+        if (!pl) {
+            handler->SendSysMessage(LANG_SELECT_PLAYER_OR_PET);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        AutoBalanceMapInfo *mapABInfo = pl->GetMap()->CustomData.GetDefault<AutoBalanceMapInfo>("AutoBalanceMapInfo");
+        handler->PSendSysMessage("Players on map: %u", mapABInfo->playerCount);
+        handler->PSendSysMessage("Max level of players in this map: %u", mapABInfo->mapLevel);
+        return true;
+    }
+
+    static bool HandleABCreatureStatsCommand(ChatHandler *handler, const char * /*args*/) {
+        Creature *target = handler->getSelectedCreature();
+
+        if (!target) {
+            handler->SendSysMessage(LANG_SELECT_CREATURE);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        AutoBalanceCreatureInfo *creatureABInfo = target->CustomData.GetDefault<AutoBalanceCreatureInfo>("AutoBalanceCreatureInfo");
+        handler->PSendSysMessage("Instance player Count: %u", creatureABInfo->instancePlayerCount);
+        handler->PSendSysMessage("Selected level: %u", creatureABInfo->selectedLevel);
+        handler->PSendSysMessage("Damage multiplier: %.6f", creatureABInfo->DamageMultiplier);
+        handler->PSendSysMessage("Health multiplier: %.6f", creatureABInfo->HealthMultiplier);
+        handler->PSendSysMessage("Mana multiplier: %.6f", creatureABInfo->ManaMultiplier);
+        handler->PSendSysMessage("Armor multiplier: %.6f", creatureABInfo->ArmorMultiplier);
+        return true;
+    }
+};
+
+void AddSC_AutoBalance() {
+    new AutoBalance_WorldScript;
+    new AutoBalance_PlayerScript;
+    new AutoBalance_UnitScript;
+    new AutoBalance_AllCreatureScript;
+    new AutoBalance_AllMapScript;
+    new AutoBalance_CommandScript;
+}
